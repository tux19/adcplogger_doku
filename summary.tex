\chapter{Summary and Conclusions}
In the course of this software project, a modular application to parse ADCP data was designed and developed for General Acoustics e.K residing in Kiel, Germany. The design was guided by requirements posed by General Acoustics e.K.. The result of the design was a component based ADCP parser built upon a threaded pipeline architecture to enhance scalability. The design is flexible and allows the addition of new functionality either as an additional components that can be executed by one of the existing threads, or as new step in the pipeline in form of an additional thread. The application features the possibility of real-time data parsing on incoming data on a serial port as well as the ability to parse old ADCP data files. Additionally it is also able to repair faulty ADCP data.\\
The implementation was done in modern C++11, new optimizing features like move semantics and shared pointers were used intensively. Each component was developed as independent as possible to decouple the whole system and raise the reuse ability. The Boost C++ libraries were used to simplify the development and allow complete portability of the code.\\
The result was a application with scalable performance depending on its configuration and the used hardware. It fulfills the requirements and surpasses them by adding a repair option to fix defective ADCP data. The application built in this project can be used in a productive environment and builds a basic framework to support upcoming projects with similar requirements.

To conclude this software project it has to be said that the developed solution has room for improvement. The code could use more and shorter methods to improve the readability and understandability. Another aspect that could be 
improved in further code revisions, is the extended use of the C++ \texttt{const} operator, to help the compiler optimizing the software.\\
Also up for further investigation is the bottleneck of the processing thread, which slows down the execution as described in Section 5.1.2. Here a solution would be to split the workload op the processing thread again into two or more threads.
