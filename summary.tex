\chapter{Summary and Conclusions}
In the course of this software project, a modular application to parse ADCP data was designed and developed for General Acoustics e.K residing in Kiel, Germany. The design was guided by requirements posed by General Acoustics e.K.. The result of the design was a component based ADCP parser built upon a threaded pipeline architecture to enhance scalability. The design is flexible and allows the addition of new functionality either as an additional components that can be executed by one of the existing threads, or as new step in the pipeline in form of an additional thread. The application features the possibility of real-time data parsing on incoming data on a serial port as well as the ability to parse old ADCP data files. Additionally it is also able to repair faulty ADCP data.\\
The implementation was done in modern C++11, new optimizing features like move semantics and shared pointers were used intensively. Each component was developed as independent as possible to decouple the whole system and raise the reuse ability. The Boost C++ libraries were used to simplify the development and allow complete portability of the code.\\
The result was a application with scalable performance depending on its configuration and the used hardware. It fulfills the requirements and surpasses them by adding a repair option to fix defective ADCP data. The application built in this project can be used in a productive environment and builds a basic framework to support upcoming projects with similar requirements.\\

To conclude this software project 

The result of this soft
% The performance requirements were not  strictly predefined. Implicitly they were given through the functionality requirements. The real-time operation, as well as post-processing of a big amount of old data should be possible in reasonable time. These requirements are satisfied by far. On a actual desktop computer with a fast SSD the application parses 180 bursts in around 30 seconds which results in around 166 ms per burst. This performance is really good!. The memory used never exceeds 28 megabytes. On the low-power data-logger the performance is slower, the CPU cannot keep up. For real-time operation the performance is by far fast enough, in 40 seconds the logger is capable to process five bursts, in real-time one burst would arrive every 10 minutes. The performance could probably be optimized in dropping the well-structured object oriented approach and working more directly with memory, bit it would be a high price to pay. One would lose the flexibility of easily adding new functionality, and the whole component based approach.
% In recapitulation of the chosen threaded architecture needs to be said that multithreaded development can be really painful. Debugging this software sometimes has cost countless hours to find segmentation faults, memory leaks or uncatched exceptions. The available toolset to debug these kind of application was small. The tools were either for Microsoft's MSVC compiler or only available on Linux. For upcoming projects it would be better to develop on either one of the platforms mentioned. At least a good heap profiler should be available.
% That said, the application with its structured and decoupled code-base in conjunction with the background information delivered in this report results in a complete package. The application is ready for productive operation. The code is ready to be used in upcoming projects, be it only through adding new functionality or completely redesigning the frame around the components. And at last the report and the documented source code delivers enough background information and overview over the application for other developers to understand the problem and start working on it for further projects.  