\chapter{Evaluation}
This chapter will discuss the result of the implementation compared to the requirements from General Acoustics e.K. The functionality will be evaluated with respect to correctness and performance. Additionally the taken implementation approaches will be reevaluated and classified based on the experiences met during the development.

The result of this software project is on one side a highly optimized, scalable and multi-functional ADCP parsing application. On the other side the created source code is highly structured and lots of components are implemented completely independent and ready to use for other projects. The implementation has been done with modern C++11 in a completely portable way as requested. It was not necessary to change a single line of code when compiling on Linux for the first time. The introduced external dependencies were limited to the Boost libraries and a lock-free queue that uses only C++ primitives.\\
The functionality of the application is as required. Real-time parsing as well as batch-processing of old raw files is implemented and works error-free. The repair functionality even extends the planned scope. The application can be parametrized depending on the available hardware and use-case.\\
The architecture is simple but variable enough to add functionality either by adding more components for each step, or by introducing new steps in form of additional threads. As described in the requirements the development of a framework around the components and realize a persistence of the components was not the target. For the scope of this project a dynamic selection of the components based on the input parameters with the ability to easily add functionality is sufficient.

The performance requirements were not  strictly predefined. Implicitly they were given through the functionality requirements. The real-time operation, as well as post-processing of a big amount of old data should be possible in reasonable time. These requirements are satisfied by far. On a actual desktop computer with a fast SSD the application parses 180 bursts in around 30 seconds which results in around 166 ms per burst. This performance is really good!. The memory used never exceeds 28 megabytes. On the low-power data-logger the performance is slower, the CPU cannot keep up. For real-time operation the performance is by far fast enough, in 40 seconds the logger is capable to process five bursts, in real-time one burst would arrive every 10 minutes. The performance could probably be optimized in dropping the well-structured object oriented approach and working more directly with memory, bit it would be a high price to pay. One would lose the flexibility of easily adding new functionality, and the whole component based approach.

In recapitulation of the chosen threaded architecture needs to be said that multithreaded development can be really painful. Debugging this software sometimes has cost countless hours to find segmentation faults, memory leaks or uncatched exceptions. The available toolset to debug these kind of application was small. The tools were either for Microsoft's MSVC compiler or only available on Linux. For upcoming projects it would be better to develop on either one of the platforms mentioned. At least a good heap profiler should be available.

That said, the application with its structured and decoupled code-base in conjunction with the background information delivered in this report results in a complete package. The application is ready for productive operation. The code is ready to be used in upcoming projects, be it only through adding new functionality or completely redesigning the frame around the components. And at last the report and the documented source code delivers enough background information and overview over the application for other developers to understand the problem and start working on it for further projects.  

